# คำตอบแลบ Big-O Time & Space Complexity

> เติมเฉพาะ **คำตอบและเหตุผลของคุณ** สำหรับแต่ละข้อ (ดูโจทย์ใน `README.md`).  
> ให้ตอบเป็น Big-O ของ **เวลา (Worst-case)** และ **พื้นที่ช่วย (Auxiliary Space)** พร้อมเหตุผลย่อ

---

## ข้อมูลผู้ส่ง
- ชื่อ – นามสกุล: พลวัต อินทมาตย์
- รหัสนักศึกษา: 1670701653
- เซกชัน: cs350_227D

## เช็กลิสต์ก่อนส่ง
- [ ] อ่านโจทย์ครบทุกข้อใน `README.md`
- [ ] คำตอบระบุ Big-O และเหตุผลย่อในแต่ละข้อ
- [ ] ไฟล์นี้ชื่อ `answers/answers.md` และถูก push ขึ้นรีโพแล้ว

--- 

## แนวทางการให้เหตุผล (แนะนำ)
- อธิบายจำนวนรอบลูปหรือจำนวนการเรียกฟังก์ชันโดยประมาณ แล้วสรุปเป็น Big-O
- ระบุว่าสิ่งใดนับเป็น **พื้นที่ช่วย** (เช่น เซต/คิว/สแตก) และสิ่งใดคือน้ำหนักของอินพุต (ไม่นับ)
- หากมีกรณีพิเศษ ให้บอกสมมติฐานที่ใช้

---

## Problem 1 — Harmonic inner loop
**Time (worst-case):** O(n log n).
เหตุผล: ลูปนอกทำงาน n รอบ (i = 1 ถึง n) ส่วนลูปในแต่ละรอบจะรันประมาณ n/i ครั้ง (j += i)  
  ดังนั้นรอบทั้งหมด ≈ ∑(n/i) = n * (1 + 1/2 + 1/3 + ... + 1/n) ≈ n * log n

**Auxiliary Space:** `O(1)`  
เหตุผล: ใช้แค่ตัวแปรนับ i, j และค่าชั่วคราว ไม่มีโครงสร้างข้อมูลเสริม

---

## Problem 2 — First duplicate ด้วยเซต
**Time (worst-case): O(n) (สมมติแฮชเฉลี่ยดี)  
เหตุผล: ลูปผ่านอาร์เรย์ความยาว n เพียงครั้งเดียว และแต่ละการตรวจสอบหรือเพิ่ม set ใช้เวลา O(1) เฉลี่ย

**Auxiliary Space:** O(n).  
เหตุผล: ในกรณีที่ไม่มีตัวซ้ำ เซตจะเก็บทุกค่าจากอาร์เรย์ทั้งหมด

**หากห้ามใช้หน่วยความจำเพิ่มเกิน O(1):**  
- วิธี/แนวคิด: จัดเรียงอาร์เรย์ก่อน แล้วไล่เช็คค่าข้างเคียง (nums[i] == nums[i+1])  
- เวลาอย่างน้อยที่ต้องใช้: O(n log n) — เนื่องจากการเรียงลำดับต้องใช้เวลาอย่างน้อย O(n log n) ในกรณีทั่วไป

---

## Problem 3 — Fibonacci แบบเรียกซ้ำ (โดยไม่มี memoization)
**Time (worst-case):** `O(2^n)`  
เหตุผล: การเรียกซ้ำแบบต้นไม้ เติบโตเป็น exponential โดยจำนวน node ≈ 2^n

**Auxiliary Space (ความลึกสแตก):** `O(n)`  
เหตุผล: ลึกสุดของสแตกการเรียกซ้ำคือ n (จาก n → n-1 → ... → 0)

> (ตัวเลือก) ถ้าใช้ **memoization/DP** เวลาและพื้นที่จะเป็นอย่างไร และเพราะเหตุใด?

---

## Problem 4 — 3-Sum ด้วย sort + two pointers
**Time (worst-case):** `O(n^2)`  
เหตุผล: เรียงลำดับ O(n log n) แล้ววนลูป i n รอบ แต่ลูปสองชั้นด้านใน (l, r) รันรวม O(n) ต่อ i หนึ่งรอบ  
  ดังนั้นรวมเป็น O(n^2) 

**Auxiliary Space:**  
- ถ้า sort **in-place** (เช่น heapsort): `O(1)` — เหตุผล: Heapsort ไม่ใช้บัฟเฟอร์เสริม  
- ถ้า sort ต้องใช้บัฟเฟอร์ (เช่น mergesort/Timsort): `O(n)` — เหตุผล: ต้องใช้บัฟเฟอร์ขนาด n ในการจัดเรียง



## อ้างอิง/บันทึกเพิ่มเติม (ถ้ามี)
- Chatgtp
